---
title: 線段樹與無修改、區間查詢問題
description: 如何將序列上的區間分治問題搬到線段樹上，支援多次詢問
toc: true
authors: []
date: 2022-11-23T20:26:39+08:00
lastmod: 2022-11-23T20:26:39+08:00
draft: false
weight: 2
---

許多題目長得像是「給你一個序列，多次詢問，每次請你回答某個區間的 XX 答案」，此類區間查詢問題往往可以用遞迴分治解決，而就像前一節提到的，蓋一棵線段樹就像把整棵遞迴樹中，每次函數呼叫需要的資訊和答案存起來，可以幫我們在多次查詢時不需要重複計算之前詢問過的區間。

## 例題 1：區間最大公因數

> 給一個序列 $a_1, a_2, a_3, \dots, a_N$，$Q$ 次詢問 $l_i, r_i$，每次請你找出所有 $a_k (k\in [l_i, r_i])$ 的最大公因數。
>
> $N, Q \leq 5\times 10^5$
>
> — 經典問題

首先觀察到，

$$
gcd(a, b, c) = gcd(a, gcd(b, c))
$$

其中 $gcd(\dots)$ 代表裡面所有數字的最大公因數。也就是說，一個區間要求 GCD，相當於砍一半、兩邊求 GCD 再求 GCD，可以分治並 $O(\log C)$ 合併（$C$ 是值域）。

如此一來線段樹上存的就會是一個區間裡所有元素的 GCD，詢問時找到所有需要的區間、把這些區間的答案求 GCD 即可。因為線段樹有 $O(N)$ 個節點，合併兩個節點的答案需要 $O(\log C)$，因此總複雜度為預處理 $O(N\log C)$、所有詢問共 $O(Q\log N\log C)$。

事實上此問題也可以用 sparse table 達到預處理 $O(N \log N \log C)$、詢問 $O(Q\log C)$。

## 反例題：區間最小公倍數

> 給一個序列 $a_1, a_2, a_3, \dots, a_N$，$Q$ 次詢問 $l_i, r_i$，每次請你找出所有 $a_k (k\in [l_i, r_i])$ 的**最小公倍數**，對 998244353 取模。
>
> $N, Q \leq 5\times 10^5$
>
> — 經典問題

取模是要避免數字大到飛起來。同樣觀察到

$$
lcm(a, b, c) = lcm(a, lcm(b, c))
$$

但是一取模，啪，沒了，剛剛的「可以砍一半分治」的性質爛掉了

$$
lcm(a, b, c) \not\equiv lcm(a, lcm(b, c) \\% M) \mod M \\
$$

{{% spoiler "例如" %}}

$$
M = 998244353 \\\\
lcm(1000000, 77771449, 48763) \equiv 901382886 \\\\
lcm(1000000, lcm(77771449, 48763)\\%M) = lcm(1000000, 38870540) \equiv 943489062
$$

{{% /spoiler %}}

所以不能用剛剛那種作法，直接每個節點維護區間 LCM 對 998244353 的餘數，這樣合併的時候會出事。不過正確作法不在本文的討論範圍。

## 例題 2：區間一次函數合成

> 給 N 個函數 $f_i(x) = a_i x + b_i$，$Q$ 次詢問 $l_i, r_i, x_i$，每次請你找出
> $$f_{r_i}(f_{r_{i-1}}(\dots f_{l_i}(x_i))) \mod 998244353$$
>
> $N, Q \leq 5\times 10^5$
>
> —[Library Checker](https://judge.yosupo.jp/problem/point_set_range_composite)（改）

取模是要避免數字大到飛起來。同樣的應用分治想法，我們可以發現：

$$
\begin{aligned}
f_2(f_1(x)) &= a_2 (a_1 x + b_1) + b_2 \cr
            &= (a_1 a_2) \cdot x + (a_2 b_1 + b_2)
\end{aligned}
$$

所以，兩個一次函數可以「合併」成一個，也就是說當我有很多個函數要合成時，我可以把這些函數分成兩半分別合成，再把兩個一次函數 $O(1)$ 合併成一個，跟上面的區間 GCD 很像。

因此每個線段樹節點會存一個一次函數，代表區間裡的所有函數合成起來的結果，詢問時合併需要的節點就可以找到一個一次函數能代表整個詢問區間合成的結果。因為合併節點是 $O(1)$，複雜度是預處理 $O(N)$、詢問 $O(Q\log N)$。

## 例題 3：潛水艇（2022 實中校內賽．改）

> 你現在是潛水艇艦長，要通過一個一維的海底隧道，同時控制著潛水艇的航行高度。隧道座標 $x \in [1, N]$，潛水艇通過 $x = i$ 時高度必須在 $[l_i, u_i]$ 範圍內。在任何時刻，你可以花 $1$ 單位能量上升或下降一單位高度。現在有 $Q$ 次詢問，每次問你若在起點終點時高度任意，從 $x = a_i$ 移動到 $x = b_i$ 至少要耗費多少能量？
>
> $N, Q \leq 2 \times 10^5$，$0 \leq u_i, l_i \leq 10^9$
>
> —2022 實中校內賽．改

~~看到 $N, Q \leq 10^5$ 就覺得很像線段樹，~~ 既然是序列題，我們不妨朝著資料結構的方向思考；而前面提到線段樹往往需要使用分治算法，因次我們很希望能夠分治解決這個問題，這樣就可以把分治搬到線段樹上做，期待他可以自動支援多次詢問。

### 潛水艇的一小步

不過，直接進入分治或許不知道從何下手，我們先從只走一步，也就是從 $x = i$ 移動到 $x = i + 1$ 的情況開始。為了方便說明，我們說一個 $[l_i, u_i]$ 是一個「單元」。

1. 情況 1-1：$[l_i, u_i]$、$[l_{i + 1}, u_{i + 1}]$ 兩個單元有交集

   因為起點終點的高度任意，只要起點高度選在 $[l_i, u_i] \cup [l_{i + 1}, u_{i + 1}]$ 的範圍內都可以不花費能量直接移動。

2. 情況 1-2：$[l_i, u_i]$、$[l_{i + 1}, u_{i + 1}]$ 兩個單元沒有交集

   若 $u_i < l_{i + 1}$，那從 $u_i$ 出發、$l_{i + 1}$ 結束一定最優，需要花費 $l_{i + 1} - u_i$ 的能量，從圖上可以看出來其他選擇都會走多餘的路。類似的， $u_{i + 1} < l_i$ 時需要花費 $l_i - u_{i + 1}$ 的能量。

![Case 1-1 and 1-2]({{< img "segment_tree/0.jpg" >}})

至於再下一步（$x = i + 2$）呢？依據前一步的結果我們還是有兩個 case：

1. 情況 2-1：前一步的終點可能在一個區間裡（剛剛用了情況 1-1）

   此時，已經知道這次起點在 $[l_i, u_i] \cup [l_{i + 1}, u_{i + 1}]$，可以視為一個單元直接套用 1-1、1-2 的討論。

2. 情況 2-2：前一步的起、終點確定了（剛剛用了情況 1-2）

   現在又有了兩個情況。首先，如果這個起點在 $[l_{i + 2}, u_{i + 2}]$ 內，可以直接走過去，不花費能量，終點還是不變。否則，選 $l_{i + 1}$、$u_{i + 1}$ 比較近的那個走過去就好了。

### 可以分治！

繼續剛剛的討論，我們可以發現走過一個區間（很多個連續的單元）會有兩種可能：

1. Type 1：區間內 $l_i, u_i$ 交集非空

   表示在區間內每次都用到情況 1-1，可能的終點在一個區間 $[max{l_i}, min{u_i}]$ 內，等同於一個單元。

2. Type 2：區間內 $l_i, u_i$ 交集為空

   表示在區間內至少用到一次情況 1-2，可能的最佳起、終點唯一。

於是我們希望，對於一個大區間可以砍成小區間，分別找到他們是哪種類型，再用某種方式合併成大區間的結果。經過一番 casework 發現兩個區間確實可以 $O(1)$ 合併，處理一下細節就完成分治的作法了。

{{% spoiler "一些 casework" %}}

![Intervals of type 1 and 2]({{< img "segment_tree/1.jpg" >}})

區間有兩種，所以把兩個區間拼起來就有四種情況

1. Type 1 + Type 1

   等同於情況 1-1、1-2，合併後可能是 Type 1/2。

2. Type 2 + Type 1

   等同於情況 2-2，合併後變成 Type 2。

3. Type 1 + Type 2

   等同於前後顛倒的情況 2-2，合併後變成 Type 2。

4. Type 2 + Type 2

   你沒有選擇，只有一條路可以走，合併後還是 Type 2。

實做上有點麻煩，要一邊算花費的能量，還要一邊維護區間的合併結果，包含起終點的高度上下界（Type 1）或起點終點高度（Type 2）。

{{% /spoiler %}}

### 搬上線段樹

只要我們知道兩個區間的結果，我們就可以 $O(1)$ 合併。因此線段樹上每個節點可以存下該區間整個合併之後是哪一種類型、和相應的資訊，寫完區間合併後剩下的就只是砸線段樹了。

複雜度跟上面兩題一模一樣是預處理 $O(N)$、詢問 $O(Q\log N)$。

## 例題 4：凸包線段樹（2021 TOI 二模）

> 平面上有 $N$ 個點，第 $i$ 個點的位置在 $p_i = (x_i, y_i)$。現在有 $Q$ 條線段從天而降，也就是從 y 座標很大很大，比所有點都大的地方往下移動，途中斜率保持不變。請你回答對於每個線段，第一個碰到線段的點是哪個。若有許多解輸出 x 最小的，若沒有碰到任何點輸出 -1。
>
> $N \leq 5 \times 10^5$，$Q \leq 10^5$，$|x|, |y| \leq 10^9$
>
> —2021 TOI 二模 pD

當然可以先把所有點照 x 座標排序，這樣就變成一個區間詢問問題：每次詢問線段在某個 $x \in [a_i, b_i]$ 區間內第一個碰到的是誰。

### 這怎麼行

一個顯然的事實是，一個區間裡要找最先碰到的的點，等於先把區間砍一半，看看兩邊最先碰到誰，再找比較早碰到的那個。然而直接搬到線段樹上，每個點維護區間裡的答案絕對是不行的，因為**合併答案時，哪個點比較好跟詢問有關**，既然我們要預處理，就不能預處理一個跟詢問有關的東西，不然下一個詢問來了，之前的資訊就沒辦法偷懶重複利用了，複雜度沒辦法進步。

### 凸包

於是我們的思考點在於，能不能做一些預處理，**維護一些資訊，讓我們在詢問時能快一點找到一個完整區間裡的答案**，這些資訊不一定直接就是答案。在這題中，凸包就是一種有用的資訊。現在考慮一個區間裡的一些點，如果這些點都在線段下方，那能影響答案的只有線段的斜率。

我們發現，第一個被碰到的點（答案）只有可能出現在這些點的**上凸包**上面，也就是下圖中橘色折線上的點，紅色線段在碰到黃色點之前就應該碰到左上角的橘色點了。

![Upper convex hull]({{< img "segment_tree/2.jpg" >}})

準確來說答案會發生在哪裡？我們知道凸包上的相鄰點連線，這些連線段斜率會從左到右遞減。而答案發生的位置，恰好會在連線段斜率「跨過」詢問線段的斜率時。也就是說，我們可以在凸包上，二分搜出第一個連線段斜率比詢問線段還小（或者最後一個比詢問線段大）的地方，這個分界點就是凸包上第一個被碰到的點，同時是整個區間的最終答案。

![Finding answer on convex hull]({{< img "segment_tree/3.jpg" >}})

實做上需要注意會不會同時碰到好幾個點，不過不是大問題。

### 線段樹

因此，我們希望能對線段樹上的每個區間（每個節點），紀錄這個區間中所有點的上凸包。對一個區間蓋凸包需要的時間是 $O(區間大小)$，要蓋好整棵線段樹所有節點上的凸包需要 $O(N\log N)$ 的時間；或者也可以對每個節點用 $O(區間大小)$ 合併底下的兩個小凸包，時間複雜度相同。詢問時，要詢問的區間依然會被拆成 $O(\log N)$ 個，每個區間需要 $O(\log N)$ 的時間找出答案候選人，再從候選人中找出最好的。

總時間複雜度：預處理 $O(N\log N)$，詢問 $O(Q \log ^2 N)$。

### 離線、優化

照著相同的想法，我們還可以進一步用離線優化複雜度。假如所有詢問已經依照斜率排序，在一個節點中詢問到的答案會遞增，那我們可以在節點中維護一個「指針」指向上一次詢問的答案，下次詢問時這個指針只會往某一邊跑，而且所有詢問問完之後這個指針至多只會移動〈區間大小〉次。所以複雜度是：

1. $O(N\log N)$ 預處理線段樹與凸包
2. $O(Q\log Q)$ 排序詢問
3. $O(Q \log N)$ 詢問
4. $O(N \log N)$ 移動每個節點的指針

一共是 $O((N+Q) \log N)$，比剛剛少了一個 $\log N$，可喜可賀。

## 總結：什麼時候可以線段樹

使用線段樹的關鍵在於，先進行一輪預處理，詢問時利用預處理算好的資訊快速找到答案。但能夠快速詢問的先決條件是：

1. 對於線段樹上被詢問完整包含的區間，可以快速找到答案
2. 對於兩段區間的答案，可以快速合併

這裡的快速指的是約 $O(\log N)$ 以內，總之不可以是 $O(區間大小)$，不然還不如直接暴力。在大多數的情況下，線段樹上可能會直接存答案，預處理算好之後 $O(1)$ 取得、合併；但也有的情況（例如例題 4）是預處理有幫助的資訊，詢問時用多一點點時間從這些資訊中進一步找答案。

我在這裡最想強調的，是線段樹重複利用資訊的精神，這個資訊未必直接是答案，但一定是可以在多次詢問時重複利用的，找到詢問之間不變的共通資訊、加以利用才能做到偷懶與加速。我第一次聽到在線段樹上蓋凸包的想法時驚為天人，希望這份驚喜能傳達給讀者！
